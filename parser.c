#include <stdio.h>
#include "front.c"
#include "parser.h"
#include "front.h"
#include <stdlib.h>

static void error();

int ExitCode;

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 *
 * */

 int main() {
    ExitCode = 0;
    printf("DCooke Analyzer ::R11766388\n");
    
    // Open the "front.c" file for reading
    if ((in_fp = fopen("example_1.dc", "r")) == NULL) {
        ExitCode = 2;
        printf("Exit Code: %d Error - cannot open file\n", ExitCode);
    } else {
        expr();
        }

        if (ExitCode == 0) {
            printf("Syntax Validated\n");
        }
    
}



/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */



void expr() 
{
    
    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
       int  currentToken = nextToken;
        lex();
        term();
          if (currentToken == ADD_OP) {
            lex();
        } else if (currentToken == SUB_OP) {
            lex();
        } else {
            error();
            return;
        }
    }

} /* End of function expr */


/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() 
{
 
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
            lex();
            factor();

         if(nextToken != MULT_OP && nextToken != DIV_OP)
        {
            error();
        }
    }
   
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor() 
{
    
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT) 
        {
        lex(); /* Get the next token */
     } 
     else
        {
        /* If the RHS is (<expr>), call lex to pass over the 
        left parenthesis, call expr, and check for the right 
        parenthesis */
        if (nextToken == LEFT_PAREN) {
            lex(); 
            expr();

            if (nextToken == RIGHT_PAREN) 
            {
                lex(); 
            } else 
            { 
                error();
            }
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
       
    } /* End of else */
   
} /* End of function factor */

static void error() 
{
    printf("Error encounter: The next lexeme was %s and the next token was %d",lexeme,nextToken);
    ExitCode = 1;
    return;
}
