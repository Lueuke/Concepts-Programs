#include <stdio.h>
#include "front.c"
#include "parser.h"
#include "front.h"

void expr();
void statements();
static void error();

int ExitCode;
/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 *
 * */

int main() {
     ExitCode = 0;
    printf("DCooke Analyzer ::R11766388\n");
    
    // Open the "front.c" file for reading
    if ((in_fp = fopen("example_2.dc", "r")) == NULL) {
        ExitCode = 2;
        printf("Exit Code: %d Error - cannot open file\n", ExitCode);

    } else {
        getChar();
        lex();
        statements();
        }
        if (ExitCode == 0) {
            printf("Syntax Validated\n");
        }
    return 0;
}

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */



void expr() 
{
    
    term();
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();     
    }
}

/* Relation (R) ::= Term (T) | R < T | R > T | R == T | R != T | R <= T | R >= T */

 /* End of function expr */

/* statements
 * Parses statements in the language generated by the grammar for S
 */
/* Comparison (C) ::= E < E | E > E | E == E | E != E | E <= E | E >= E */

void comparison() {
    expr();  // Parse the left expression

    // Check for comparison operators and parse the right expression
    while (nextToken == LESSER_OP || nextToken == GREATER_OP || nextToken == EQUAL_OP ||
           nextToken == NEQUAL_OP || nextToken == LEQUAL_OP || nextToken == GEQUAL_OP) {
        lex();  // Consume the operator
        expr();  // Parse the right expression
    }
}

/* statements
 * Parses statements in the language generated by the grammar for S
 */
/* statements
 * Parses statements in the language generated by the grammar for S
 */
void statements() {
    if (nextToken == KEY_DO) {
        // Handle do...while loop
        lex(); // Consume the "do" keyword
        if (nextToken == LEFT_CBRACE) {
            lex(); // Consume the "{"
            statements(); // Recursively parse statements inside the loop
            if (nextToken == RIGHT_CBRACE) {
                lex(); // Consume the "}"
            } else {
                error();
            }
        } else {
            error();
        }
    } else if (nextToken == KEY_WHILE) {
        // Handle while loop
        lex(); // Consume the "while"
        if (nextToken == LEFT_PAREN) {
            lex(); // Consume the "("
            expr(); // Parse the loop condition
            comparison();
            if (nextToken == RIGHT_PAREN) {
                lex(); // Consume the ")"
                if (nextToken == SEMICOLON) {
                    lex(); // Consume the final semicolon
                } else {
                    error();
                }
            } else {
                error();
            }
        } else {
            error();
        }
    }  if (nextToken == IDENT) {
        lex(); // Consume the identifier
        if (nextToken = INC_OP || nextToken == DEC_OP)
        {
            lex();
        }
        
        else if (nextToken == ASSIGN_OP) {
            lex(); // Consume the "="
            expr(); // Parse the assignment expression
            if (nextToken == SEMICOLON) {
                lex(); // Consume the semicolon
            } else {
                error();
            }
        } else {
            error();
        }
    } else if (nextToken == KEY_READ) {
        lex(); // Consume the "read" keyword
        if (nextToken == LEFT_PAREN) {
            lex(); // Consume the "("
            if (nextToken == IDENT) {
                lex(); // Consume the identifier
                if (nextToken == RIGHT_PAREN) {
                    lex(); // Consume the ")"
                    if (nextToken == SEMICOLON) {
                        lex(); // Consume the semicolon
                    } else {
                        error();
                    }
                } else {
                    error();
                }
            } else {
                error();
            }
        } else {
            error();
        }
    } else if (nextToken == KEY_WRITE) {
        lex(); // Consume the "write" keyword
        if (nextToken == LEFT_PAREN) {
            lex(); // Consume the "("

            expr(); // Parse the expression to be written

            if (nextToken == RIGHT_PAREN) {
                lex(); // Consume the ")"
                if (nextToken == SEMICOLON) {
                    lex(); // Consume the semicolon
                } else {
                    error();
                }
            } else {
                error();
            }
        } else {
            error();
        }
    }
}



/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() 
{

    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) 
    {
            lex();
            factor();
    }


} /* End of function term */



void factor() 
{

     if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); /* Get the next token */
    } else if (nextToken == LEFT_PAREN) {
        lex(); 
        expr();
        if (nextToken == RIGHT_PAREN) {
            lex(); 
        } else {
            error();
        }
    } else {
        error();
    }
}



 /* End of function factor */

const char* getTokenName(int token) {
    switch (token) {
        case INT_LIT:
            return "INT_LIT";
        case IDENT:
            return "IDENT";
        case LESSER_OP:
            return "LESSER_OP";
        case GREATER_OP:
            return "GREATER_OP";
        case EQUAL_OP:
            return "EQUAL_OP";
        case NEQUAL_OP:
            return "NEQUAL_OP";
        case LEQUAL_OP:
            return "LEQUAL_OP";
        case GEQUAL_OP:
            return "GEQUAL_OP";
        case SEMICOLON:
            return "SEMICOLON";
        case INC_OP:
            return "INC_OP"; 
        case DEC_OP:
            return "DEC_OP"; 
        case ASSIGN_OP:
            return "ASSIGN_OP";
        case ADD_OP:
            return "ADD_OP";
        case SUB_OP:
            return "SUB_OP";
        case MULT_OP:
            return "MULT_OP";
        case DIV_OP:
            return "DIV_OP";
        case LEFT_PAREN:
            return "LEFT_PAREN";
        case RIGHT_PAREN:
            return "RIGHT_PAREN";
        case LEFT_CBRACE:
            return "LEFT_CBRACE";
        case RIGHT_CBRACE:
            return "RIGHT_CBRACE";
        case KEY_READ:
            return "KEY_READ";
        case KEY_WRITE:
            return "KEY_WRITE";
        case KEY_WHILE:
            return "KEY_WHILE";
        case KEY_DO:
            return "KEY_DO";
        default:
            return "UNKNOWN";
    }
}

static void error() 
{
    printf("Error encounter: The next lexeme was %s and the next token was %s",lexeme,getTokenName(nextToken));
    ExitCode = 1;
    return;
}
