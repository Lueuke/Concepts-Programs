#include <stdio.h>
#include "front.c"
#include "parser.h"
#include "front.h"

void expr();
void statements();
static void error();

int ExitCode;
/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 *
 * */

int main() {
     ExitCode = 0;
    printf("DCooke Analyzer ::R11766388\n");
    
    // Open the "front.c" file for reading
    if ((in_fp = fopen("example_2.dc", "r")) == NULL) {
        ExitCode = 2;
        printf("Exit Code: %d Error - cannot open file\n", ExitCode);
<<<<<<< Updated upstream
    } else {
        getChar();
        lex();
        statements();
=======
    } else 
        {
         getChar();
         lex();
>>>>>>> Stashed changes
        }
        if (ExitCode == 0) {
            printf("Syntax Validated\n");
        }
    return 0;
}

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
<<<<<<< Updated upstream
/* Expression (E) ::= Relation (R) | E + T | E - T */
void expr() {
=======


void expr() 
{
    
    /* Parse the first term */
>>>>>>> Stashed changes
    term();
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
<<<<<<< Updated upstream
    term();     
    }
}

/* Relation (R) ::= Term (T) | R < T | R > T | R == T | R != T | R <= T | R >= T */

 /* End of function expr */

/* statements
 * Parses statements in the language generated by the grammar for S
 */

void statements() {
    while (1) {
        if (nextToken == IDENT) {
            lex(); // Consume the identifier
            if (nextToken == ASSIGN_OP) {
                lex(); 
                expr();
            } else {
                error();
                return;
            }
        } else if (nextToken == KEY_READ) {
            lex(); 
            if (nextToken == LEFT_PAREN) {
                lex(); 
                if (nextToken == IDENT) {
                    lex(); 
                } else {
                    error();
                    return;
                }
                if (nextToken == RIGHT_PAREN) {
                    lex(); 
                } else {
                    error();
                    return;
                }
            } else {
                error();
                return;
            }
        } else if (nextToken == KEY_WRITE) {
            lex(); 
            if (nextToken == LEFT_PAREN) {
                lex();
                expr(); 
                if (nextToken == RIGHT_PAREN) {
                    lex(); 
                } else {
                    error();
                    return;
                }
            } else {
                error();
                return;
            }
        } else if (nextToken == KEY_DO) {
            lex(); 
            if (nextToken == LEFT_CBRACE) {
                lex(); 
                statements(); 
                if (nextToken == RIGHT_CBRACE) {
                    lex();
                } else {
                    error();
                    return;
                }
                if (nextToken == KEY_WHILE) {
                    lex(); 
                    if (nextToken == LEFT_PAREN) {
                        lex(); 
                        expr(); 
                        if (nextToken == RIGHT_PAREN) {
                            lex(); 
                        } else {
                            error();
                            return;
                        }
                    } else {
                        error();
                        return;
                    }
                } else {
                    error();
                    return;
                }
            } else {
                error();
                return;
            }
        } else if (nextToken == SEMICOLON) {
            lex();
           
        } else {
            break; 
        }
=======
        term();
         
>>>>>>> Stashed changes
    }
}

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() 
{
 
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) 
    {
            lex();
            factor();
    }
    if (nextToken == INC_OP)
    {
        lex();
    }
    

} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor() 
{
 
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); /* Get the next token */
<<<<<<< Updated upstream
    } else {
     
        if (nextToken == LEFT_PAREN) {
            lex(); 
            expr();

            if (nextToken == RIGHT_PAREN) {
=======
     } 
     else
        {
        /* If the RHS is (<expr>), call lex to pass over the 
        left parenthesis, call expr, and check for the right 
        parenthesis */
        if (nextToken == LEFT_PAREN) 
        {
            lex(); 
            expr();
            if (nextToken == RIGHT_PAREN) 
            {
>>>>>>> Stashed changes
                lex(); 
            } else { 
                error();
            }
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
        else 
        { 
            error(); 
        }
    } /* End of else */
   
} /* End of function factor */

const char* getTokenName(int token) {
    switch (token) {
        case INT_LIT:
            return "INT_LIT";
        case IDENT:
            return "IDENT";
        case LESSER_OP:
            return "LESSER_OP";
        case GREATER_OP:
            return "GREATER_OP";
        case EQUAL_OP:
            return "EQUAL_OP";
        case NEQUAL_OP:
            return "NEQUAL_OP";
        case LEQUAL_OP:
            return "LEQUAL_OP";
        case GEQUAL_OP:
            return "GEQUAL_OP";
        case SEMICOLON:
            return "SEMICOLON";
        case INC_OP:
            return "INC_OP"; 
        case DEC_OP:
            return "DEC_OP"; 
        case ASSIGN_OP:
            return "ASSIGN_OP";
        case ADD_OP:
            return "ADD_OP";
        case SUB_OP:
            return "SUB_OP";
        case MULT_OP:
            return "MULT_OP";
        case DIV_OP:
            return "DIV_OP";
        case LEFT_PAREN:
            return "LEFT_PAREN";
        case RIGHT_PAREN:
            return "RIGHT_PAREN";
        case LEFT_CBRACE:
            return "LEFT_CBRACE";
        case RIGHT_CBRACE:
            return "RIGHT_CBRACE";
        case KEY_READ:
            return "KEY_READ";
        case KEY_WRITE:
            return "KEY_WRITE";
        case KEY_WHILE:
            return "KEY_WHILE";
        case KEY_DO:
            return "KEY_DO";
        default:
            return "UNKNOWN";
    }
}

static void error() 
{
    printf("Error encounter: The next lexeme was %s and the next token was %s",lexeme,getTokenName(nextToken));
    ExitCode = 1;
    return;
}